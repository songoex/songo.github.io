<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>2020总结 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://songoex.github.io/favicon.ico?v=1613643307745">
<link rel="stylesheet" href="https://songoex.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、面试常见问题回忆
Sql：
1.用一条sql语句查询出“每门”课程都大于80分的学生姓名
select name from (select name,min(score) from student group by name havin..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://songoex.github.io">
        <img src="https://songoex.github.io/images/avatar.png?v=1613643307745" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://songoex.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">2020总结</h2>
            <div class="post-date">2021-02-18</div>
            
              <div class="feature-container" style="background-image: url('https://songoex.github.io/post-images/2020-zong-jie.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p>一、面试常见问题回忆<br>
Sql：<br>
1.用一条sql语句查询出“每门”课程都大于80分的学生姓名<br>
select name from (select name,min(score) from student group by name having min(score)&gt;80) stu<br>
SELECT test1.NAME,b.grade,b.<code>subject</code> FROM test1 LEFT JOIN ( SELECT test2.stu_id,SUM( grade ) AS grade,test2.<code>subject</code><br>
FROM test2  GROUP BY test2.SUBJECT,test2.stu_id HAVING grade &gt;222 ) AS b ON test1.stu_id = b.stu_id<br>
2.左连接和右连接的区别<br>
简单的来说，左连接只影响右表，右连接只影响左表<br>
简单来说：<br>
左连接：左边有的，右边没有的为null<br>
右连接：左边没有的，右边有的为null<br>
左连接where只影向右表，右连接where只影响左表<br>
3. drop，truncate，delete 三者的区别<br>
drop：删除内容和定义，释放空间。（表结构和数据一同删除）<br>
truncate：删除内容，不删除定义，释放空间（表结构还在，数据删除）<br>
delete：删除内容，不删除定义，也不释放空间<br>
3.1.Delete from表名 [where 删除条件]​<br>
3.2.Truncate table 表名    注：不能用于有外键约束的表，删除速度比delete快，从标识列开始，相当于delete没有where条件<br>
区别：<br>
1.使用delete进行删除数据，删除后，标识列继续增长，不会从标示种子开始<br>
2.如果存在主外键关系，先删除子表中的数据，再删除主表中的数据<br>
3.使用Truncate删除数据之后，再插入数据，标识列从标示种子开始，不能用于有主外键约束的表<br>
4.索引<br>
分类：<br>
单值索引是指一个索引只包含一个字段，一个表可以创建多个单值索引，但也不宜过多<br>
主键创建后一定包含一个唯一索引；但唯一索引不一定是主键，允许有空值，一个表可以创建多个唯一索引<br>
因为一个查询一次至多只能使用一个索引,所以,如果都使用单值索引,在数据量较大的情况下,不能很好的区分数据，于是引入了复合索引，复合索引是有顺序的<br>
选择哪些列创建索引？<br>
1.查询较为频繁的字段应该创建索引；<br>
2.唯一性太差的字段不应该创建索引，就算这个字段经常作为查询条件；<br>
3.更新频繁的字段不应该创建索引，索引是需要维护成本的；<br>
4.有where条件时才会走索引，所以如果这个列不会作为where的查询条件，没有必要为这个字段创建索引；<br>
5. 数据库四大特性<br>
原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败<br>
一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态<br>
隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离<br>
持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响<br>
6.四种隔离级别<br>
读未提交、读提交、可重复读、串行化</p>
<p>7.mysql<br>
行存储,存储结构分为聚簇索引（innodb）和非聚簇索引（myisam），均是采用b+树结构<br>
聚簇索引：<br>
必有主键索引，主键索引的叶子节点存储了表的数据。非叶子节点都是索引关键字，但是不是记录数据或者数据地址<br>
非聚簇索引：<br>
主键索引和二级索引存储上没有任何区别，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据</p>
<ol start="8">
<li>MQ<br>
8.1 生产者丢失消息<br>
8.2 Mq丢失消息<br>
8.3 消费者丢失消息<br>
8.4 重复消费</li>
</ol>
<p>9.kafka\redis(rdb和aof的区别)</p>
<p>10.性能测试关注的指标</p>
<p>Linux：<br>
1.du和df的区别<br>
du通过搜索文件获取大小的，删除的不会显示<br>
df通过通过文件系统从硬盘获取，即使删除的也会显示<br>
2.查询关键字出现的次数<br>
grep -o ‘objStr’  filename|wc -l<br>
3. 从日志中查出具体某个用户某个时间段的日志<br>
sed -n '/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p'  test.log<br>
jvm：<br>
内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间<br>
内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用</p>
<p>网络：</p>
<ol>
<li>在浏览器输入URL回车之后发生了什么？</li>
<li>URL 解析2.DNS 查询<br>
3.TCP 连接（三次握手）4.http发起请求<br>
5.服务端处理请求6.浏览器解析资源渲染页面<br>
7.关闭tcp连接（四次握手）</li>
<li>Http和Https的区别<br>
https比http多了一个ssl加密<br>
http默认端口号80  https默认端口号443<br>
301永久重定向    302暂时重定向<br>
从网络角度，502已经与后端建立了连接，但超时；<br>
504与后端连接未建立，超时<br>
3.TCP和udp的区别<br>
TCP 是面向连接的、UDP 是面向无连接的<br>
TCP 保证数据正确性，UDP 可能丢包<br>
TCP 保证数据顺序，UDP 不保证<br>
TCP数据传输慢，UDP数据传送快<br>
每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>
4.三次握手<br>
第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号。<br>
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</li>
</ol>
<p>Python：</p>
<ol>
<li>深浅复制<br>
浅拷贝：指向同一块内存，和切片一样[:]<br>
深拷贝：指向不同的内存<br>
2.递归</li>
<li>必须有一个明确的结束条件</li>
<li>每次进入更深一层递归时，问题规模相比上次递归都应有所减少</li>
<li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</li>
</ol>
<p>斐波那契<br>
def fab(n)<br>
if n&lt;1:<br>
print(&quot;输入有误!&quot;)<br>
if n<mark>1 or n</mark>2:<br>
return 1<br>
else:<br>
return fab(n-1)=fab（n-2）<br>
3.闭包：<br>
内部函数的代码包含对外部作用域的引用 （其实重点就是要明白函数名也是变量）<br>
内部函数的代码包含对外层函数的局部变量的引用<br>
优点：<br>
1.保护变量不被其他人侵害<br>
2.保持变量常驻内存</p>
<p>def fun1(x):<br>
def fun2(y):<br>
return(x*y)<br>
return fun2<br>
fun1(2)(6)<br>
4.装饰器<br>
def timer(func):<br>
def deco():<br>
func()<br>
return deco</p>
<p>@timer #test1=timer(test1)<br>
def test1():<br>
pass<br>
test1()<br>
from functools import wraps<br>
def a(func):<br>
@wraps(func)<br>
def b(*args,**kwargs):<br>
func(*args,**kwargs)<br>
4. python的多进程怎么实现的？（GIL）是怎样的？迭代器和生成器？<br>
1.process、自定义类、进程池<br>
节省io操作时间，而不是cpu计算时间，因为cpu计算很快，无法把一条进程中所有的io操作都规避掉<br>
2. GIL保证同一时刻只有一个线程执行代码，每个线程在执行过程中都要先获取GIL，只有在CPython中有<br>
3.迭代器<br>
特点：1.节省内存2.惰性机制3.不能反复，只能向下执行<br>
4.生成器<br>
生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator，iter（）可以把Iterable变成Iterator<br>
一边循环一边计算，那么可以使用next（a1）一个一个的显示生成器a1的返回值a1.<strong>next</strong>()</p>
<ol start="5">
<li>使用python求一个数组中,是否有两个数的相加,等于期望值,如果有,输出这两个数的索引<br>
a=[1,7,9,4,5]<br>
s=8<br>
for index,i in enumerate(a):<br>
for index2,j in enumerate(a[index+1:]):<br>
if i+j == s:<br>
print(index+1,index2+2)</li>
</ol>
<p>6.字符串每个元素出现的次数<br>
方式一：<br>
s=&quot;taiBaiBBBzsB&quot;<br>
result={}<br>
for i in set(s):<br>
result[i]=s.count(i)<br>
print(result)<br>
from collections import Counter<br>
string=&quot;hello world&quot;<br>
Counter(string)<br>
6A.快速排序<br>
def quick_sort(b):<br>
2     &quot;&quot;&quot;快速排序&quot;&quot;&quot;<br>
3      if len(b) &lt; 2:<br>
4          return arr<br>
5     # 选取基准，随便选哪个都可以，选中间的便于理解<br>
6      mid = b[len(b) // 2]<br>
7     # 定义基准值左右两个数列<br>
8      left, right = [], []<br>
9     # 从原始数组中移除基准值<br>
10      b.remove(mid)<br>
11      for item in b:<br>
12         # 大于基准值放右边<br>
13          if item &gt;= mid:<br>
14              right.append(item)<br>
15          else:<br>
16             # 小于基准值放左边<br>
17              left.append(item)<br>
18     # 使用迭代进行比较<br>
19      return quick_sort(left) + [mid] + quick_sort(right)</p>
<p>7.冒泡排序<br>
def Bubble(lst):<br>
for a in range(len(lst)):<br>
for i in range(len(lst)-1):<br>
if lst[i]&gt;lst[i+1]:<br>
lst[i],lst[i+1]=lst[i+1],lst[i]<br>
return lst<br>
插入排序<br>
def insert_sort(data_list):<br>
lenght=len(data_list)<br>
for i in range(1,lenght):<br>
key=data_list[i]<br>
j=i-1<br>
while j&gt;=0:<br>
if data_list[j]&gt;key:<br>
data_list[j+1]=data_list[j]<br>
data_list[j]=key<br>
j=j-1<br>
return data_list</p>
<ol start="7">
<li>
<p>单例模式<br>
from threading import Thread,Lock<br>
class A:<br>
__instance=None<br>
lock=Lock()<br>
def <strong>new</strong>(cls, *args, **kwargs):<br>
with cls.lock:<br>
if cls.__instance == None:<br>
cls.__instance=super().<strong>new</strong>(cls)<br>
return cls.__instance<br>
def func():<br>
a=A()<br>
print(a)<br>
for i in range(10):<br>
Thread(target=func).start()</p>
</li>
<li>
<p>字符串翻转<br>
A=&quot;defgh&quot;<br>
B=[]<br>
for i in range(0,len(A)):<br>
B.append(A[len(A)-1-i])<br>
print(&quot;&quot;.join(B))<br>
10.将字符串数字转化为整数<br>
s = &quot;123&quot;<br>
s = s[::-1]<br>
num = 0<br>
for i ,v in enumerate(s):<br>
for j in range(0,10):<br>
if v == str(j):<br>
num += j <em>(10**i)<br>
比较版本号<br>
def compareVersion(self, version1: str, version2: str) -&gt; int:<br>
lst1 = version1.split(&quot;.&quot;)<br>
lst2 = version2.split(&quot;.&quot;)<br>
L1 = len(lst1)<br>
L2 = len(lst2)<br>
if L1 &lt; L2:<br>
lst1.extend([&quot;0&quot;]</em>(L2-L1))<br>
else:<br>
lst2.extend([&quot;0&quot;]*(L1-L2))<br>
L = max(L1, L2)<br>
for i in range(L):<br>
if int(lst1[i]) &lt; int(lst2[i]):<br>
return -1<br>
if int(lst1[i]) &gt; int(lst2[i]):<br>
return 1<br>
return 0<br>
9.判断是否有相同的元素<br>
str=[1,2,3,4,5]<br>
if len(str)==len(set(str)):<br>
print &quot;no dump&quot;<br>
else:<br>
print &quot;dump&quot;</p>
</li>
</ol>
<p>selenium原理：<br>
原理：<br>
1)启动浏览器后，selenium-webdriver会将目标浏览器绑定到特定的端口，启动后的浏览器则作为webdriver的remote server。<br>
2)客户端(也就是测试脚本)，借助ComandExecutor发送HTTP请求给sever端(指浏览器)。<br>
3)Sever端需要依赖原生的浏览器组件，转化Web Service的命令为浏览器native的调用来完成操作。<br>
Appium原理：<br>
我们的电脑（client）上运行自动化测试脚本，调用的是webdriver的接口，appium server接收到我们client上发送过来的命令后他会将这些命令转换为UIautomator认识的命令，然后由UIautomator来在设备上执行自动化。</p>
<p>常见的问题：</p>
<ol>
<li>环境准备</li>
<li>编写脚本</li>
<li>运行时是否稳定</li>
<li>排查问题</li>
<li>用例数量</li>
</ol>
<p>Redis：<br>
1.缓存穿透：指缓存和数据库中都没有的数据，而用户不断发起请求<br>
2.缓存击穿：指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力<br>
3.缓存雪崩：指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机<br>
持久化rdb、aof</p>
<p>安卓的四大组件<br>
Activity： 是用户和应用程序交互的窗口。<br>
Service：<br>
BroadCast Recevicer：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，，统一了Android的事件广播模型 Content provider：内容提供者，可通过它来共享自己的数据给外部调用，给第三方应用提供数据访问的接口</p>
<p>反转字符串<br>
class Solution:<br>
def reverseString(self, s):<br>
s[:]=s[::-1]</p>
<p>反转字符串中的单词<br>
def reverseWords(self, s) :<br>
return ' '.join(s.split(' ')[::-1])[::-1]</p>
<p>字符串转换整数<br>
s=s[::-1]<br>
num=0<br>
for index,I in enumerate(s):<br>
for y in range(0,10):<br>
If i==str(y):<br>
num+=y*(10**index)</p>
<p>查找一个字符串在另一个字符串中开始得位置<br>
def strStr( haystack, needle):<br>
m = len(needle)<br>
for i in range(len(haystack)-m+1):<br>
if haystack[i:m+i] == needle:<br>
return i<br>
return -1</p>
<p>最长公共前缀<br>
def longestCommonPrefix(strs):<br>
ans = ''<br>
for i in zip(*strs):<br>
if len(set(i)) == 1:<br>
ans += i[0]<br>
else:<br>
break<br>
return ans</p>
<p>列表元素右移动n个位置（也就是最后一个变成第一个）<br>
def func(s,n):<br>
while n&gt;0:<br>
s.insert(0,s.pop())<br>
n=n-1<br>
return s<br>
列表元素左移动n个位置<br>
def func(s,n):<br>
return s[n:]+s[:n]</p>
<p>找出列表中只出现一次的元素<br>
def func(s):<br>
return sum(set(s))*2-sum(s)</p>
<p>列表中，俩数相加等于期望值<br>
def func(list,num):<br>
for index1,I in enumerate(list):<br>
for index2,y in enumerate(a[index+1:])<br>
If i+y=num<br>
print(index1+1,index2+2)</p>
<p>判断是否为顺子<br>
def func(list1):<br>
for i in range(len(list1)):<br>
if len(list1)-i==1:<br>
break<br>
a = list1[i + 1] - list1[i]<br>
if list1[i] == 0:<br>
print('5张牌中出现大小王，不是顺子')<br>
break<br>
if a != 1:<br>
print('不是顺子')<br>
break</p>
<p>找出字符串s中给定起始字符串和终止字符串的中间字符串，如s=“abcdefdfgg” Begins= bc endstr=df 则返回def</p>
<p>def GetMiddleStr(content,startStr,endStr):<br>
startIndex = content.index(startStr)<br>
if startIndex&gt;=0:<br>
startIndex += len(startStr)<br>
endIndex = content.index(endStr)<br>
return content[startIndex:endIndex]</p>
<p>冒泡排序<br>
def func(list):<br>
for I in range(len(list)):<br>
for y in range(len(list)-1):<br>
if list[y]&gt;list[y+1]:<br>
list[y],list[y+1]=list[y+1],list[y]<br>
return list</p>
<p>二分查找法<br>
def func(list,a):<br>
first=0<br>
last=len(list)-1<br>
while first&lt;=last:<br>
mid=(first+last)//2<br>
if list[mid]==a:<br>
return True<br>
elif a&lt;list[mid]:<br>
last=mid-1<br>
else:<br>
first=mid-1<br>
return Flase</p>
<p>0-100内的素数<br>
L=[]<br>
for x in range(100):<br>
if x&lt;2:<br>
continue<br>
for i in range(2,x):<br>
if x%i==0:<br>
break<br>
else:               #走到此处，x一定是素数<br>
L.append(x)</p>
<p>爬楼梯，一步两步</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://songoex.github.io/post/appium/">
                  <h3 class="post-title">
                    appium笔记
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
